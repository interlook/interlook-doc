{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Interlook Dynamically provision (V)IP, DNS record and Load Balancer configuration based on services deployed on container platform.","title":"Home"},{"location":"#interlook","text":"Dynamically provision (V)IP, DNS record and Load Balancer configuration based on services deployed on container platform.","title":"Interlook"},{"location":"concept/","text":"Architecture Technically, providers and provisioners are all implementations of the Extension interface. Currently supported Providers: * ~~Docker~~ * Docker Swarm (not tested yet) * Docker Enterprise (Swarm) * ~~Consul Catalog~~ Currently supported Provisioners: * IP: * ipalloc (an embedded simple local IPAM) * ~~GestioIP~~ * DNS: * Consul (DNS records will contain Consul specific suffix: .service. consul-domain , use CoreDNS with rewrite) * Load Balancer: * Kemp LoadMaster * F5 Big-IP LTM","title":"Concept"},{"location":"concept/#architecture","text":"Technically, providers and provisioners are all implementations of the Extension interface. Currently supported Providers: * ~~Docker~~ * Docker Swarm (not tested yet) * Docker Enterprise (Swarm) * ~~Consul Catalog~~ Currently supported Provisioners: * IP: * ipalloc (an embedded simple local IPAM) * ~~GestioIP~~ * DNS: * Consul (DNS records will contain Consul specific suffix: .service. consul-domain , use CoreDNS with rewrite) * Load Balancer: * Kemp LoadMaster * F5 Big-IP LTM","title":"Architecture"},{"location":"configuration/","text":"Configuration Interlook uses a yaml formatted configuration file. The file contains different sections: core: Configure interlook's core module core: logLevel: DEBUG listenPort: 8080 logFile : stdout # workflowSteps: comma separated succession of extenstions workflowSteps: provider.swarm,ipam.ipalloc,lb.f5ltm # where the workflow entries are saved workflowEntriesFile: ./share/flowentries.db # how often should the workflow controller run workflowActivityLauncherInterval: 3s # how often should the workflow housekeeper run workflowHousekeeperInterval: 60s # close the entry in error if work in progress for longer than serviceWIPTimeout: 90s # remove entries that have been closed for time cleanUndeployedServiceAfter: 10m # trigger a refresh request to provider if service has not been updated since serviceMaxLastUpdated: 90s The other sections configure the provider and the provisioners . Each component has its own configuration. Refer to the extension implementation in the component package. For example for ipalloc refer to the package in provisioner\\ipam\\ipalloc. provider provider: swarm: endpoint: tcp://ucp.csnet.me:443 labelSelector: - l7aas tlsCa: /path/to/ca.pem tlsCert: /path/to/cert.pem tlsKey: /path/to/key.pem pollInterval: 5s ipam ipam: ipalloc: network_cidr: 192.168.99.0/24 db_file: ./share/conf/allocated.db dns dns: consul: url: http://127.0.0.1:8500 domain: token: lb lb: kemplm: endpoint: https://192.168.99.2 username: api password: apiPassw0rd httpPort: httpsPort:","title":"Configuration"},{"location":"configuration/#configuration","text":"Interlook uses a yaml formatted configuration file. The file contains different sections: core: Configure interlook's core module core: logLevel: DEBUG listenPort: 8080 logFile : stdout # workflowSteps: comma separated succession of extenstions workflowSteps: provider.swarm,ipam.ipalloc,lb.f5ltm # where the workflow entries are saved workflowEntriesFile: ./share/flowentries.db # how often should the workflow controller run workflowActivityLauncherInterval: 3s # how often should the workflow housekeeper run workflowHousekeeperInterval: 60s # close the entry in error if work in progress for longer than serviceWIPTimeout: 90s # remove entries that have been closed for time cleanUndeployedServiceAfter: 10m # trigger a refresh request to provider if service has not been updated since serviceMaxLastUpdated: 90s The other sections configure the provider and the provisioners . Each component has its own configuration. Refer to the extension implementation in the component package. For example for ipalloc refer to the package in provisioner\\ipam\\ipalloc. provider provider: swarm: endpoint: tcp://ucp.csnet.me:443 labelSelector: - l7aas tlsCa: /path/to/ca.pem tlsCert: /path/to/cert.pem tlsKey: /path/to/key.pem pollInterval: 5s ipam ipam: ipalloc: network_cidr: 192.168.99.0/24 db_file: ./share/conf/allocated.db dns dns: consul: url: http://127.0.0.1:8500 domain: token: lb lb: kemplm: endpoint: https://192.168.99.2 username: api password: apiPassw0rd httpPort: httpsPort:","title":"Configuration"},{"location":"extension/","text":"Developing an Interlook extension Interface An Interlook extension must first implement the Extension interface: type Extension interface { Start(receive -chan service.Message, send chan - service.Message) error Stop() error } The Start method will be used by the core to start the extension. The core will provide a receive and send channels for the exchanged messages. The Stop method is used to shut the extension down. When invoked, it must make sure that Start method is stopped and return to the invoker. Configuration The configuration is read at interlook startup. The config package must import the extension's configuration object. Interlook configuration is a yaml formatted file and the Go object is config.ServerConfiguration. Here is an example for an IPAM IPAlloc extension: IPAM struct { IPAlloc *ipalloc.Provisioner `yaml: ipalloc,omitempty ` } `yaml: ipam,omitempty ` On startup, interlook will start all extensions that are configured in the core.workflow setup. If a configured extension fails to start, interlook will panic. Messages Two actions must be supported for incoming messages: add : when core sends such a message, it means the extension must create or update the existing service definition delete: service is being un-deployed, so the extension can delete current definition Once processed, the message must be sent back to the core using the send channel. If applicable, the service definition can be modified by the extension. In case of error, the extension must raise it through the Message.Error field.","title":"Extend Interlook"},{"location":"extension/#developing-an-interlook-extension","text":"","title":"Developing an Interlook extension"},{"location":"extension/#interface","text":"An Interlook extension must first implement the Extension interface: type Extension interface { Start(receive -chan service.Message, send chan - service.Message) error Stop() error } The Start method will be used by the core to start the extension. The core will provide a receive and send channels for the exchanged messages. The Stop method is used to shut the extension down. When invoked, it must make sure that Start method is stopped and return to the invoker.","title":"Interface"},{"location":"extension/#configuration","text":"The configuration is read at interlook startup. The config package must import the extension's configuration object. Interlook configuration is a yaml formatted file and the Go object is config.ServerConfiguration. Here is an example for an IPAM IPAlloc extension: IPAM struct { IPAlloc *ipalloc.Provisioner `yaml: ipalloc,omitempty ` } `yaml: ipam,omitempty ` On startup, interlook will start all extensions that are configured in the core.workflow setup. If a configured extension fails to start, interlook will panic.","title":"Configuration"},{"location":"extension/#messages","text":"Two actions must be supported for incoming messages: add : when core sends such a message, it means the extension must create or update the existing service definition delete: service is being un-deployed, so the extension can delete current definition Once processed, the message must be sent back to the core using the send channel. If applicable, the service definition can be modified by the extension. In case of error, the extension must raise it through the Message.Error field.","title":"Messages"},{"location":"extensions/","text":"","title":"Extensions"},{"location":"workflow/","text":"Workflow This doc describes the interlook workflow by explaining a basic example. interlook creates a listener for each configured extension. This listener will receive all messages/events coming from a given extension. Those events, together with their state will be stored in an entry list. In order to bring the services to the desired state (deployed or undeployed), interlook polls the entry list at an interval defined in the config ( core.checkFlowInterval ). It then sends an event to the corresponding extension. The extension is handling the required action and sending back the status to the core listener. Example We have a provider (docker) that publishes services on given host(s) / port When we get a new service definition from docker, we want to get an IP from our IPAM component (local file) In the yml config file, our workflow definition will be: provider.docker,ipam.ipalloc The internal flow/message exchange will be like this: 1. Provider to workflow Docker provider pushes a newly published service. The listener gets it and inject it to the workflow |Provider| - Listener - |workflow| state:provider.docker wip:false 2. The workflowController detects the new entry workflowController check current state against the expected state. If it does not match, sets the next step/extension, changes the status to \"wip\" and sends the message to the next extension (IPAM) |workflow| - flowControl - |IPAM| state:ipam.ipalloc wip:true 3. The IPAM extension sends back a message IPAM extension does it's job and gets an IP for us. Then it sends back the message |IPAM| - Listener - |workflow| state:ipam.file state:ipam.ipalloc wip:true wip:false 4. Closing the flow In our example the ipalloc extension is the last step of the workflow. The flow control module detects that \"ipam.ipalloc\" is the last step in our workflow. As we have reached the final step, it updates the entry's state to deployed, closing the flow. |workflow| state:deployed wip:false","title":"Workflow"},{"location":"workflow/#workflow","text":"This doc describes the interlook workflow by explaining a basic example. interlook creates a listener for each configured extension. This listener will receive all messages/events coming from a given extension. Those events, together with their state will be stored in an entry list. In order to bring the services to the desired state (deployed or undeployed), interlook polls the entry list at an interval defined in the config ( core.checkFlowInterval ). It then sends an event to the corresponding extension. The extension is handling the required action and sending back the status to the core listener.","title":"Workflow"},{"location":"workflow/#example","text":"We have a provider (docker) that publishes services on given host(s) / port When we get a new service definition from docker, we want to get an IP from our IPAM component (local file) In the yml config file, our workflow definition will be: provider.docker,ipam.ipalloc The internal flow/message exchange will be like this:","title":"Example"},{"location":"workflow/#1-provider-to-workflow","text":"Docker provider pushes a newly published service. The listener gets it and inject it to the workflow |Provider| - Listener - |workflow| state:provider.docker wip:false","title":"1. Provider to workflow"},{"location":"workflow/#2-the-workflowcontroller-detects-the-new-entry","text":"workflowController check current state against the expected state. If it does not match, sets the next step/extension, changes the status to \"wip\" and sends the message to the next extension (IPAM) |workflow| - flowControl - |IPAM| state:ipam.ipalloc wip:true","title":"2. The workflowController detects the new entry"},{"location":"workflow/#3-the-ipam-extension-sends-back-a-message","text":"IPAM extension does it's job and gets an IP for us. Then it sends back the message |IPAM| - Listener - |workflow| state:ipam.file state:ipam.ipalloc wip:true wip:false","title":"3. The IPAM extension sends back a message"},{"location":"workflow/#4-closing-the-flow","text":"In our example the ipalloc extension is the last step of the workflow. The flow control module detects that \"ipam.ipalloc\" is the last step in our workflow. As we have reached the final step, it updates the entry's state to deployed, closing the flow. |workflow| state:deployed wip:false","title":"4. Closing the flow"}]}